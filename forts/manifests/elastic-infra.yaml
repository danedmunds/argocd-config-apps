apiVersion: v1
kind: ServiceAccount
metadata:
  labels:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: elastic-infra
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/version: 0.46.0
    helm.sh/chart: ingress-nginx-3.19.0
  name: elastic-infra-ingress-nginx
---
apiVersion: v1
data:
  tls.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURWRENDQWp5Z0F3SUJBZ0lKQUowdHFNVDVEV3BzTUEwR0NTcUdTSWIzRFFFQkN3VUFNRDh4R0RBV0JnTlYKQkFNTUQyVnNZWE4wYVdNdVpYaGhiWEJzWlRFak1DRUdBMVVFQ2d3YVpXeGhjM1JwWXkxbGJHRnpkR2xqTFd4dgpZMkZzTFdObGNuUXdIaGNOTVRnd05qRXhNVFV4TVRBeldoY05Namd3TkRFNU1UVXhNVEF6V2pBL01SZ3dGZ1lEClZRUUREQTlsYkdGemRHbGpMbVY0WVcxd2JHVXhJekFoQmdOVkJBb01HbVZzWVhOMGFXTXRaV3hoYzNScFl5MXMKYjJOaGJDMWpaWEowTUlJQklqQU5CZ2txaGtpRzl3MEJBUUVGQUFPQ0FROEFNSUlCQ2dLQ0FRRUFwUUxJZ1Z4QwpkRjI3UFhzL3M4VFh2VGRVeTVwZFFneG9jWi9MenUxblJXbW1GRUc1Mlo5MmRjS1dJMDljdVg5ZUlZZzE0c21ZCkczSmtjb28vNUt0WUtpNmh5dVBtNlZrdGRyU1dCam1VdGxkbHg3UVRLNkxFVlhFeUU3VDZ6QW1GV3lMZTVJMEIKbDdRQlk2dnVoK3g1dlpkSWd3SzVldzBFZmNJUU1Ra2tiMzVkb00xYm41TEJEVklxUzNmNXUxNTArMTM1RitsWQpOc2lFcWhZaVExZm1PMmkzSzBLOW5TMEl3Nm5vNWp2MkZaNnR5bU9zY2wvaWYzdWQzUzUxOTZNTjJtaFpCRFVaCmlwbThlRVkxNVJOa3VQSXBETzhMYkEwZlFOcUcyYXFGa3JybFcrbEdTaDRYZjZLNmdtZkFRdW15K2xrR3RqVlUKZU5OdGF6NnlMMWNkU3dJREFRQUJvMU13VVRBTEJnTlZIUThFQkFNQ0JMQXdFd1lEVlIwbEJBd3dDZ1lJS3dZQgpCUVVIQXdFd0xRWURWUjBSQkNZd0pJSVBaV3hoYzNScFl5NWxlR0Z0Y0d4bGdoRXFMbVZzWVhOMGFXTXVaWGhoCmJYQnNaVEFOQmdrcWhraUc5dzBCQVFzRkFBT0NBUUVBVDFnMFhqelNDRDBBTkF5cDFOWURLU3ZZVUdHcGpSaFkKdUJRYnRwcDUrUDNzd2xvdTNvMDVwdDNydlZ3QmxwK2tjalFwTEJpN3AyRFNuNTdFWHM5eHFEQTBHRjlMSHdpUwpzcGZVYlhRazJIa1E3SGpHb01FSEJLVWpOVUJoZjJkWVRuK1BtbHhobllpZitoU2dkeDdIZ1JuMTh0K0hqTC9JClVlUUkxMHYvdExiT1diZkdBZmlGYjQyUHEvVjg1aGJlNW9mU1VObHVsNFZNOGVXNk1SNlB2b1dYYWJYcVB2ajMKSXpVOVk2UVFoN2dqYmNQN2RmWUZCd3FFRnUxOHlpMUdFbzcxK0NtUjFFL2VpK2kzZDdZTHlMTWhUOHZnMVNDUgozeTB1TVZZOHkxVHpIdS9OTEl0NVozYm1rNFJjcUo1MDVsYmtrTHdzSVFYUzJpMUxud25weXc9PQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg==
  tls.key: LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JSUV2QUlCQURBTkJna3Foa2lHOXcwQkFRRUZBQVNDQktZd2dnU2lBZ0VBQW9JQkFRQ2xBc2lCWEVKMFhiczkKZXorenhOZTlOMVRMbWwxQ0RHaHhuOHZPN1dkRmFhWVVRYm5abjNaMXdwWWpUMXk1ZjE0aGlEWGl5WmdiY21SeQppai9rcTFncUxxSEs0K2JwV1MxMnRKWUdPWlMyVjJYSHRCTXJvc1JWY1RJVHRQck1DWVZiSXQ3a2pRR1h0QUZqCnErNkg3SG05bDBpREFybDdEUVI5d2hBeENTUnZmbDJnelZ1ZmtzRU5VaXBMZC9tN1huVDdYZmtYNlZnMnlJU3EKRmlKRFYrWTdhTGNyUXIyZExRakRxZWptTy9ZVm5xM0tZNnh5WCtKL2U1M2RMblgzb3czYWFGa0VOUm1LbWJ4NApSalhsRTJTNDhpa003d3RzRFI5QTJvYlpxb1dTdXVWYjZVWktIaGQvb3JxQ1o4QkM2Ykw2V1FhMk5WUjQwMjFyClBySXZWeDFMQWdNQkFBRUNnZ0VBZUVPWUNSaEo0dS94cUxTc1VBUldUTFVJRzBDTldiY2JaRHpYMlNBVUZYWVQKc2szWSszQ0tjUGQ2WDQvVy8rZUJucVRjeVVhdWtzcUR4U3RYdC96ZHpCaWltUElUZU4wakVwSTVpWjNyOGgydQpzNmRlRlg2UzQ4Y1ZmV0Y1TEw1L3NGV3c2QmlSSVpUek1rYThHZHJUTzhnSDlGeEcvUlVXd2VWdjBaMWRMZGhiCkY3MXB4SjJiUUYvaWhQTmo5TW53NGt2NkkrcW81NjBDZTd0dW5GODRnOS91MFMzTGlwVFRXc0tsTWNjS0liR1UKWUovNHRkRU5Cd3ErKzU2cXh1bGJEcXA4QnJQNHJVbnFFNUg4MEZwNTFQYkI0V2E4aysybStBVHVmQ3RpZ0FCSAo3Z0ljTnNMRGRuRnhXRjNENlg5OUlqdndFRGZIUGFxSzBDaFFKQTIvcVFLQmdRRFErM3VJTXgrUHRkMkhPTVJmCmY4VFVEN1BudkhXaUo1YTE2YzBwcTNrYzdFei9mZHlwbU1mbXRzMERnUXJsNTBTM0YrYjNOSUFtUVhQZHd3d3AKaFhBUktrZ0F5QXUrRDdlVFVEajBoa0ZzZ1hUeWxyL0FnMGlDOU9tMUhFVFVEbGpzUS94TWFYcSt0R2tBVEhpMwowVy9mOHYzSWRBNW9Fblg1VUdac1htNkU5d0tCZ1FES0lybSt5Z1B3ZndwcWkraW02djkvNzcwRVZDU0NJNjNtCi9teWtmZXVNVVFwcHY2RDBZS25ha21RcXBPRFI5cFRNK01yS01DTi9TdkZVeDdDR0FwbjNUKzRKTjhMb05kVTQKaG0yYmtmY05MbGtPMGtmRHVKOHA2M1ZNeEs1OUthbVNhY2hBU0JLVlpoZEMxK0lpNkUwQ2NrVFAwWFpuU0NJRApaOGFEellzWlRRS0JnRmZLUFdQQzdqQkYyeER5RlBSMVRTODBoWVFGRkhtUkhldS9rdk05V0h5QSsvdWNXUFZaCi9DZjhoUFZDNFZ3aElpbTBQYzk5VzVRMmpNRU5MZS9IWVlPa2VtanhvSlV3THhNUWNVeXZsWTVLZCtGczJKSzcKMDl0SG5XSDZ4U003LzdrSStsVHpQcUFjVTd2UFpDcjhMWDRycXRicGdoL1FHWVVwZEUxMEFnT1RBb0dBSW5ragpwb2M3ZnNPYjJpbjhScU5qYWNWUVBqRy9mRFpyalM2dEJxeTNCRm81NVdrYUlUTnZKR2k5RG96S0R1VDM0YkU0Cm5KenpJTjErSlJCZGFhMTk1ckRLRHVaa3BrZXdFcERTbHFxaE1LMUw0UHc1NHdaVWxzaWlXN0piYzlzc0lWMUwKR3JOdi8rekdZTThDc1NOZkp1Q29IYTFDZlVEUEZEZVpvcGJtZHkwQ2dZQlpZTk01NFlPck12VjBJU3FibmEvQwpPQWMrci8yWU5BQmQvNFRHcFgzVHNpTHlTaG5YS04zbVcveEQxb2RUTkZNRVcwSFAza2c3NDhmMVNLSjNVWkJzCjBHcG80aHo4dlZYYUJDNmxDVkd3dnNwWWJkUDJBOEdQbkFOREpud2pyUEp1Q2xTZC9Hcm9tSVBuSVBtQTErVWkKWVRERFhZVWU2TVhncUUxc2lZU2x0Zz09Ci0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0K
kind: Secret
metadata:
  labels:
    app: elastic-infra
    chart: elastic-infra-4.9.1
    heritage: Helm
    release: elastic-infra
  name: elastic-infra-elastic-infra-tls-secret
type: kubernetes.io/tls
---
apiVersion: v1
data:
  enable-opentracing: "true"
  http-snippet: |
    # set some custom opentracing tags
    opentracing_tag http.user_agent $http_user_agent;
    opentracing_tag http.proto $server_protocol;
    opentracing_tag nginx.request_id $request_id;
  jaeger-collector-host: $JAEGER_AGENT_HOST
  jaeger-propagation-format: w3c
  jaeger-service-name: elastic-infra-nginx-ingress
  proxy-add-original-uri-header: "true"
  worker-shutdown-timeout: 300s
kind: ConfigMap
metadata:
  labels:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: elastic-infra
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/version: 0.46.0
    helm.sh/chart: ingress-nginx-3.19.0
  name: elastic-infra-ingress-nginx-controller
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  labels:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: elastic-infra
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/version: 0.46.0
    helm.sh/chart: ingress-nginx-3.19.0
  name: elastic-infra-ingress-nginx
rules:
  - apiGroups:
      - ""
    resources:
      - namespaces
    verbs:
      - get
  - apiGroups:
      - ""
    resources:
      - configmaps
      - pods
      - secrets
      - endpoints
    verbs:
      - get
      - list
      - watch
  - apiGroups:
      - ""
    resources:
      - services
    verbs:
      - get
      - list
      - update
      - watch
  - apiGroups:
      - extensions
      - networking.k8s.io
    resources:
      - ingresses
    verbs:
      - get
      - list
      - watch
  - apiGroups:
      - extensions
      - networking.k8s.io
    resources:
      - ingresses/status
    verbs:
      - update
  - apiGroups:
      - networking.k8s.io
    resources:
      - ingressclasses
    verbs:
      - get
      - list
      - watch
  - apiGroups:
      - ""
    resourceNames:
      - ingress-controller-leader-nginx
    resources:
      - configmaps
    verbs:
      - get
      - update
  - apiGroups:
      - ""
    resources:
      - configmaps
    verbs:
      - create
  - apiGroups:
      - ""
    resources:
      - endpoints
    verbs:
      - create
      - get
      - update
  - apiGroups:
      - ""
    resources:
      - events
    verbs:
      - create
      - patch
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  labels:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: elastic-infra
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/version: 0.46.0
    helm.sh/chart: ingress-nginx-3.19.0
  name: elastic-infra-ingress-nginx
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: elastic-infra-ingress-nginx
subjects:
  - kind: ServiceAccount
    name: elastic-infra-ingress-nginx
    namespace: default
---
apiVersion: v1
kind: Service
metadata:
  annotations:
    prometheus.io/port: "10254"
    prometheus.io/scrape: "true"
  labels:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: elastic-infra
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/version: 0.46.0
    helm.sh/chart: ingress-nginx-3.19.0
  name: elastic-infra-ingress-nginx-controller-metrics
spec:
  ports:
    - name: metrics
      port: 9913
      targetPort: metrics
  selector:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: elastic-infra
    app.kubernetes.io/name: ingress-nginx
  type: ClusterIP
---
apiVersion: v1
kind: Service
metadata:
  annotations: null
  labels:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: elastic-infra
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/version: 0.46.0
    helm.sh/chart: ingress-nginx-3.19.0
  name: elastic-infra-ingress-nginx-controller
spec:
  ports:
    - name: http
      port: 80
      protocol: TCP
      targetPort: http
    - name: https
      port: 443
      protocol: TCP
      targetPort: https
  selector:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: elastic-infra
    app.kubernetes.io/name: ingress-nginx
  type: LoadBalancer
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  labels:
    app: elastic-infra
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: elastic-infra
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/version: 0.46.0
    helm.sh/chart: ingress-nginx-3.19.0
    release: elastic-infra
  name: elastic-infra-ingress-nginx-controller
spec:
  minReadySeconds: 0
  revisionHistoryLimit: 10
  selector:
    matchLabels:
      app.kubernetes.io/component: controller
      app.kubernetes.io/instance: elastic-infra
      app.kubernetes.io/name: ingress-nginx
  template:
    metadata:
      labels:
        app.kubernetes.io/component: controller
        app.kubernetes.io/instance: elastic-infra
        app.kubernetes.io/name: ingress-nginx
    spec:
      containers:
        - args:
            - /nginx-ingress-controller
            - --election-id=ingress-controller-leader
            - --ingress-class=nginx
            - --configmap=default/elastic-infra-ingress-nginx-controller
            - --watch-namespace=default
            - --default-ssl-certificate=$(SSL_CERT_SECRET)
            - --metrics-per-host=false
          env:
            - name: POD_NAME
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
            - name: POD_NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
            - name: LD_PRELOAD
              value: /usr/local/lib/libmimalloc.so
            - name: JAEGER_AGENT_HOST
              valueFrom:
                fieldRef:
                  fieldPath: status.hostIP
            - name: OTEL_EXPORTER_OTLP_ENDPOINT
              value: $(JAEGER_AGENT_HOST):55680
          image: ghcr.io/qlik-trial/nginx-ingress-controller:2.10.1
          imagePullPolicy: IfNotPresent
          lifecycle:
            preStop:
              exec:
                command:
                  - /wait-shutdown
          livenessProbe:
            failureThreshold: 3
            httpGet:
              path: /healthz
              port: 10254
              scheme: HTTP
            initialDelaySeconds: 10
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 1
          name: ingress-nginx-controller
          ports:
            - containerPort: 80
              hostPort: 80
              name: http
              protocol: TCP
            - containerPort: 443
              hostPort: 443
              name: https
              protocol: TCP
            - containerPort: 10254
              name: metrics
              protocol: TCP
          readinessProbe:
            failureThreshold: 3
            httpGet:
              path: /healthz
              port: 10254
              scheme: HTTP
            initialDelaySeconds: 10
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 1
          securityContext:
            allowPrivilegeEscalation: true
            capabilities:
              add:
                - NET_BIND_SERVICE
              drop:
                - ALL
            runAsUser: 101
      dnsPolicy: ClusterFirst
      imagePullSecrets:
        - name: artifactory-docker-secret
      nodeSelector:
        kubernetes.io/os: linux
      serviceAccountName: elastic-infra-ingress-nginx
      terminationGracePeriodSeconds: 300
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  annotations:
    nginx.ingress.kubernetes.io/auth-response-headers: Authorization
    nginx.ingress.kubernetes.io/auth-url: http://edge-auth.$(NAMESPACE).svc.cluster.local:8080/v1/auth
    nginx.ingress.kubernetes.io/configuration-snippet: |
      more_set_headers 'Access-Control-Allow-Origin: $http_origin';
      more_set_headers 'Access-Control-Allow-Methods: GET, PUT, POST, DELETE, PATCH, OPTIONS';
      if ($request_method = 'OPTIONS') {
        more_set_headers 'Access-Control-Max-Age: 1728000';
        more_set_headers 'Content-Type: text/plain charset=UTF-8';
        more_set_headers 'Content-Length: 0';
        return 204;
      }
      return 404;
    nginx.ingress.kubernetes.io/proxy-body-size: 500m
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/server-snippet: "opentracing on;\n\ngzip on;\ngzip_min_length 10240;\ngzip_proxied expired no-cache no-store private auth;\ngzip_types text/plain text/css text/xml text/javascript application/x-javascript application/json application/xml;\ngzip_disable msie6;\nserver_tokens off;\n\n# Do not store anything in cache unless specific location overrides\nmore_set_headers \"Cache-Control: no-store\" \"Pragma: no-cache\";\n\n# Enforce HSTS\nmore_set_headers \"Strict-Transport-Security: max-age=15724800; includeSubDomains\";\n\n\n\n# The following location is for converting a edge-auth 500 to 429 if the reason for the 500 is rate-limiting\nlocation @rate_limiting {\n  if ($rate_limited) {\n    more_clear_headers 'Content-Type';\n    add_header Content-Type application/json always;\n    add_header Retry-After $rate_limited_retry_after always;\n    return 429 $rate_limited_response_body;\n  }\n  return 500;\n}\n\n# The following custom auth block is required so we can have a reliable auth path for engine load balancing (below)\nlocation = /_external-auth-engine {\n  internal;\n\n  proxy_pass_request_body     off;\n  proxy_set_header            X-Forwarded-Proto \"\";\n\n  proxy_set_header            Host                    edge-auth.default.svc.cluster.local;\n  proxy_set_header            X-Original-URL          $scheme://$http_host$request_uri;\n  proxy_set_header            X-Original-Method       $request_method;\n  proxy_set_header            X-Sent-From             \"nginx-ingress-controller\";\n  proxy_set_header            X-Real-IP               $remote_addr;\n  proxy_set_header            Connection              $connection_upgrade;\n  proxy_set_header            Upgrade                 $http_upgrade;\n\n  proxy_set_header            X-Forwarded-For        $remote_addr;\n\n  proxy_set_header            X-Auth-Request-Redirect $request_uri;\n\n  proxy_buffering                         off;\n  proxy_buffer_size                       4k;\n  proxy_buffers                           4 4k;\n  proxy_request_buffering                 on;\n\n  proxy_http_version          1.1;\n  proxy_ssl_server_name       on;\n  proxy_pass_request_headers  on;\n\n  client_max_body_size        \"1m\";\n\n  # Pass the extracted client certificate to the auth provider\n\n  set $target http://edge-auth.$(NAMESPACE).svc.cluster.local:8080/v1/auth;\n  opentracing_propagate_context;\n  \n  proxy_pass $target;\n}\n\n# The following is for dataprepservice as a load balancer\nlocation = /_dataprepservice_special {\n  internal;\n\n  proxy_set_header            Content-Type \"application/json\";\n\n  set $target http://data-prep.$(NAMESPACE).svc.cluster.local:9072/session/route;\n  opentracing_propagate_context;\n  \n  proxy_pass $target;\n}\n\n# This block controls the data-prep websocket LB and proxying logic\nlocation ~ ^/dataprepservice/app/(.+) {\n  set $dps_path '';\n\n  set $app_id $1;\n\n  access_by_lua_block {\n    local bridge_tracer = require(\"opentracing_bridge_tracer\")\n    local tracer = bridge_tracer.new_from_global()\n    local parent_context = tracer:binary_extract(ngx.var.opentracing_binary_context)\n    local span = tracer:start_span(\"dataprep_lua_ws\", {[\"references\"] = { {\"child_of\", parent_context} } })\n\n    local headers = {}\n    for h,v in pairs(ngx.req.get_headers()) do\n        headers[h] = v\n    end\n    tracer:http_headers_inject(span:context(), headers)\n\n    local authres = ngx.location.capture(\"/_external-auth-engine\", { headers = headers })\n\n    span:set_tag(\"auth.status\", authres.status)\n    if authres.status ~= ngx.HTTP_OK then\n      ngx.log(ngx.ERR, authres.status .. \" received from edge_auth\")\n      span:set_tag(\"error\", true)\n      span:finish()\n      if authres.status == ngx.HTTP_UNAUTHORIZED or authres.status == ngx.HTTP_FORBIDDEN then\n        ngx.exit(authres.status)\n        return\n      else\n        ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)\n        return\n      end\n    end\n\n    -- Set upstream Authorization header\n    ngx.req.set_header(\"Authorization\", authres.header[\"Authorization\"])\n\n    local dpsHeaders = {}\n    for h,v in pairs(ngx.req.get_headers()) do\n        dpsHeaders[h] = v\n    end\n    dpsHeaders[\"Authorization\"] = authres.header[\"Authorization\"]\n    tracer:http_headers_inject(span:context(), dpsHeaders)\n\n    local reqBody = \"{\\\"appId\\\":\\\"\" .. ngx.var.app_id .. \"\\\"}\"\n    local dps_res = ngx.location.capture(\"/_dataprepservice_special\", {\n      method = ngx.HTTP_POST,\n      headers = dpsHeaders,\n      body = reqBody\n    })\n\n    span:set_tag(\"data.prep.status\", dps_res.status)\n    if dps_res.status ~= ngx.HTTP_OK then\n      ngx.log(ngx.ERR, \"error from dataprepservice route request = \" .. dps_res.status)\n      span:set_tag(\"error\", true)\n      span:finish()\n      ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)\n      return\n    end\n\n    local cjson = require \"cjson\";\n    local dps_route_data = cjson.decode(dps_res.body);\n    local dps_path = dps_route_data.url\n    if not dps_path then\n      ngx.log(ngx.ERR, \"invalid or empty path received from dataprepservice\")\n      span:set_tag(\"error\", true)\n      span:finish()\n      ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)\n      return\n    end\n\n    ngx.var.dps_path = string.format(\"%s/app/%s\", dps_path, ngx.var.app_id)\n    ngx.log(ngx.NOTICE, \"forwarding dataprepservice WS request to url \" .. ngx.var.dps_path)\n    span:set_tag(\"data.prep.path\", ngx.var.dps_path)\n    span:finish()\n  }\n\n  proxy_set_header X-Real-IP $proxy_protocol_addr;\n  proxy_set_header X-Forwarded-For $proxy_protocol_addr;\n  proxy_set_header X-Forwarded-Port 80;\n  proxy_set_header X-Forwarded-Proto $scheme;\n  proxy_set_header Host $http_host;\n  proxy_set_header X-NginX-Proxy true;\n  proxy_set_header Connection $connection_upgrade;\n  proxy_set_header Upgrade $http_upgrade;\n  proxy_connect_timeout 7d;\n  proxy_read_timeout 7d;\n  proxy_send_timeout 7d;\n  proxy_http_version 1.1;\n  opentracing_propagate_context;\n  \n  proxy_pass $dps_path;\n}\n\n# This block controls the data-prep REST API LB and proxying logic\n# It has the form: /api/dataprepservice/v1/apps/$1/model/$2/$3\nlocation ~ ^/api/dataprepservice/v1/apps/([^/]*)/model/(current|session)/(.*) {\n  # cors support\n  if ( $http_origin ) {\n    set $Access_Control_Allow_Origin $http_origin;\n    set $Access_Control_Allow_Credentials \"true\";\n    set $Access_Control_Allow_Methods \"GET, PUT, POST, DELETE, PATCH, OPTIONS\";\n    set $Access_Control_Allow_Headers \"x-qlik-xrfkey,DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization,Qlik-Web-Integration-ID,Qlik-CSRF-Token\";\n    set $Access_Control_Max_Age \"1728000\";\n    set $Access_Control_Expose_Headers \"Qlik-CSRF-Token,Content-Location\";\n  }\n  if ($request_method = 'OPTIONS') {\n    more_set_headers 'Access-Control-Allow-Origin: $Access_Control_Allow_Origin';\n    more_set_headers 'Access-Control-Allow-Credentials: $Access_Control_Allow_Credentials';\n    more_set_headers 'Access-Control-Allow-Methods: $Access_Control_Allow_Methods';\n    more_set_headers 'Access-Control-Allow-Headers: $Access_Control_Allow_Headers';\n    more_set_headers 'Access-Control-Max-Age: $Access_Control_Max_Age';\n    more_set_headers 'Content-Type: text/plain charset=UTF-8';\n    more_set_headers 'Content-Length: 0';\n    return 204;\n  }\n  more_set_headers 'Access-Control-Allow-Origin: $Access_Control_Allow_Origin';\n  more_set_headers 'Access-Control-Allow-Credentials: $Access_Control_Allow_Credentials';\n  more_set_headers 'Access-Control-Allow-Methods: $Access_Control_Allow_Methods';\n  more_set_headers 'Access-Control-Allow-Headers: $Access_Control_Allow_Headers';\n  more_set_headers 'Access-Control-Expose-Headers: $Access_Control_Expose_Headers';\n\n  set $dps_path '';\n  set $auth_path http://edge-auth.$(NAMESPACE).svc.cluster.local:8080/v1/auth;\n  set $dps_route_path http://data-prep.$(NAMESPACE).svc.cluster.local:9072/session/route;\n\n  set $app_id $1;\n  set $prefix $2;\n  set $end_point $3;\n\n  set $redir https://$best_http_host$request_uri;\n  # enforce ssl on server side\n  access_by_lua_block {\n    local bridge_tracer = require(\"opentracing_bridge_tracer\")\n    local tracer = bridge_tracer.new_from_global()\n    local parent_context = tracer:binary_extract(ngx.var.opentracing_binary_context)\n    local span = tracer:start_span(\"dataprep_lua_rest\", {[\"references\"] = { {\"child_of\", parent_context} } })\n\n    local function redirect_to_https()\n      return ngx.var.pass_access_scheme == \"http\" and (ngx.var.scheme == \"http\" or ngx.var.scheme == \"https\")\n    end\n\n    if redirect_to_https() then\n      span:finish()\n      ngx.redirect(ngx.var.redir, ngx.HTTP_MOVED_PERMANETLY)\n      return\n    end\n\n    local http = require \"resty.http\"\n    local httpc = http.new()\n\n    local random = math.random\n\n    local function guid()\n      local template ='xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'\n      return string.gsub(template, '[xy]', function (found)\n        local gen = (found == 'x') and random(0, 0xf) or random(8, 0xb)\n        return string.format('%x', gen)\n      end)\n    end\n\n    local headers = {}\n    for h,v in pairs(ngx.req.get_headers()) do\n      headers[h] = v\n    end\n    headers[\"Host\"] = \"edge-auth.default.svc.cluster.local\"\n    headers[\"X-Original-URL\"] = string.format(\"%s://%s%s\", ngx.var.scheme, ngx.var.http_host, ngx.var.request_uri)\n    headers[\"X-Original-Method\"] = ngx.var.request_method\n    headers[\"X-Sent-From\"] = \"nginx-ingress-controller\"\n    headers[\"X-Real-IP\"] = ngx.var.the_real_ip\n    headers[\"X-Forwarded-For\"] = ngx.var.the_real_ip\n    headers[\"X-Auth-Request-Redirect\"] = ngx.var.request_uri\n    headers[\"X-DataPrep-Lua-Request-ID\"] = guid()\n    tracer:http_headers_inject(span:context(), headers)\n\n    local res, err = httpc:request_uri(ngx.var.auth_path, {\n        headers = headers,\n        keepalive = false})\n\n    if err then\n      local hdrStr = \"\"\n      for key,value in pairs(headers) do\n        if string.lower(key) ~= \"cookie\"  then\n          hdrStr = hdrStr .. key .. \":\" .. value .. \" \"\n        end\n      end\n      ngx.log(ngx.ERR, \"error calling edge_auth \" .. tostring(err) .. \" auth headers: \" .. hdrStr .. \" edge_auth URI: \" .. ngx.var.auth_path)\n      span:set_tag(\"error\", true)\n      span:finish()\n      ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)\n      return\n    end\n\n    span:set_tag(\"auth.status\", res.status)\n    if res.status ~= ngx.HTTP_OK then\n      ngx.log(ngx.ERR, res.status .. \" received from edge_auth\")\n      span:set_tag(\"error\", true)\n      span:finish()\n      if res.status == ngx.HTTP_UNAUTHORIZED or res.status == ngx.HTTP_FORBIDDEN then\n        ngx.exit(res.status)\n        return\n      else\n        ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)\n        return\n      end\n    end\n\n    -- Set upstream Authorization header\n    ngx.req.set_header(\"Authorization\", res.headers[\"Authorization\"])\n\n    local reqHeaders = {}\n    reqHeaders[\"Content-Type\"] = \"application/json\"\n    reqHeaders[\"Authorization\"] = res.headers[\"Authorization\"]\n    tracer:http_headers_inject(span:context(), reqHeaders)\n\n    local reqBody = \"{\\\"appId\\\":\\\"\" .. ngx.var.app_id .. \"\\\"}\"\n\n    local dps_res, dps_err = httpc:request_uri(ngx.var.dps_route_path, {\n      method = \"POST\",\n      keepalive = false,\n      headers = reqHeaders,\n      body = reqBody\n    })\n\n    if dps_err then\n      ngx.log(ngx.ERR, \"error calling dataprepservice: \" .. tostring(dps_err))\n      span:set_tag(\"error\", true)\n      span:finish()\n      ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)\n      return\n    end\n\n    span:set_tag(\"data.prep.status\", dps_res.status)\n    if dps_res.status ~= ngx.HTTP_OK then\n      ngx.log(ngx.ERR, \"error from dataprepservice route request: \" .. dps_res.status)\n      span:set_tag(\"error\", true)\n      span:finish()\n      ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)\n      return\n    end\n\n    local cjson = require \"cjson\";\n    local dps_route_data = cjson.decode(dps_res.body);\n    local dps_path = dps_route_data.url\n    if not dps_path then\n      ngx.log(ngx.ERR, \"invalid or empty path received from dataprepservice\")\n      span:set_tag(\"error\", true)\n      span:finish()\n      ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)\n      return\n    end\n\n    local query_params = ngx.encode_args(ngx.req.get_uri_args())\n    if query_params then\n      query_params = \"?\" .. query_params\n    end\n\n    ngx.var.dps_path = string.format(\"%s/v1/apps/%s/model/%s/%s%s\", dps_path, ngx.var.app_id, ngx.var.prefix, ngx.var.end_point, query_params)\n    ngx.log(ngx.NOTICE, \"forwarding dataprepservice request to url \" .. ngx.var.dps_path)\n    span:set_tag(\"data.prep.path\", ngx.var.dps_path)\n    span:finish()\n  }\n\n  proxy_set_header X-Real-IP $proxy_protocol_addr;\n  proxy_set_header X-Forwarded-For $proxy_protocol_addr;\n  proxy_set_header X-Forwarded-Port 80;\n  proxy_set_header X-Forwarded-Proto $scheme;\n  proxy_set_header Host $http_host;\n  proxy_set_header X-NginX-Proxy true;\n  proxy_connect_timeout 7d;\n  proxy_read_timeout 7d;\n  proxy_send_timeout 7d;\n  opentracing_propagate_context;\n  \n  proxy_pass $dps_path;\n}\n"
    nginx.org/client-max-body-size: 500m
  labels:
    app: elastic-infra
    chart: elastic-infra-4.9.1
    heritage: Helm
    release: elastic-infra
  name: elastic-infra-elastic-infra-api-404
spec:
  ingressClassName: nginx
  rules:
    - http:
        paths:
          - backend:
              service:
                name: elastic-infra-ingress-nginx-controller
                port:
                  number: 80
            path: /api
            pathType: ImplementationSpecific
